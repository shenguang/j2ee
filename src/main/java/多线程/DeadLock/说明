什么是死锁
    两个或者两个以上线程，在竞争资源时或者相互通信时产生相互阻塞，如无外力的作用无法推进下去。
例子：
    T1事务在拥有R1（资源）时请求R2资源
    T2事务在拥有R2（资源）时请求R1资源
    这时T1是无法请求到R2资源的，T2在占有
特性：
    --占有性： 一个资源同一时间只能有一个进程占有
    --请求保持：在获取资源时阻塞的情况下，持有锁保持不放。
    --不被剥夺：自己获取自己释放，其他进程不可剥夺
    --循环等待：就是相互等待

避免死锁的方法：
    --加锁的顺序
    --加锁时间
数据中的死锁：
    --一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；
解决方法：加锁顺序。
例子：
--用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，
而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁。
解决方法：1：防治重复提交，2：使用乐观锁，3：使用悲观锁
mysql查询死锁：
show OPEN TABLES where In_use > 0;show processlist ;kill id

java 查看死锁：
经验之谈：首先我会看看代码, 如果我看到一个嵌套的同步块，或从一个同步的方法调用其他同步方法, 或试图在不同的对象上获取锁, 如果开发人员不是非常小心，就很容易造成死锁。
jconsol==》线程==》检查死锁按钮  ：哪个线程持有那个锁
jstock查询：
jps（查出类的进程id）==》jstack -L id ==》出现deadLock信息（哪个线程持有那个锁）